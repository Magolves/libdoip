<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdoip: Example DoIP Server Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libdoip
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">DoIP (Diagnostics over Internet Protocol) ISO 13400 C++17 Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doc_ExampleDoIPServer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Example DoIP Server Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page describes how to build and run the example DoIP server included with the libdoip project, and how to customize its UDS behavior.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p>The example server application demonstrates a minimal DoIP server using the library's <code>DoIPServer</code>, <code>DoIPConnection</code> and <code>DoIPServerModel</code> types. The relevant example source files are located in the <code>examples/</code> directory:</p>
<ul>
<li><code>examples/exampleDoIPServer.cpp</code> — program entry point and socket setup.</li>
<li><code>examples/ExampleDoIPServerModel.h</code> — example <code>DoIPServerModel</code> with ready-made UDS handlers and a small worker thread that simulates a downstream transport (e.g. CAN).</li>
</ul>
<p>The example shows how to:</p>
<ul>
<li>Configure server properties (VIN, logical gateway address, announcement settings).</li>
<li>Open UDP and TCP sockets for DoIP announcements and diagnostic connections.</li>
<li>Register UDS handlers using the <code>uds::UdsMock</code> test helper for local request handling.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Files of interest</h1>
<ul>
<li><code><a class="el" href="DoIPServerModel_8h.html">inc/DoIPServerModel.h</a></code> — contains the <code>DoIPServerModel</code> callbacks that the application implements for connection-open, close and diagnostic message handling. Customize these callbacks to integrate your ECU logic.</li>
<li><code>examples/ExampleDoIPServerModel.h</code> — shows a concrete <code>DoIPServerModel</code> implementation used by the example server. UDS handlers are registered via <code>uds::UdsMock</code> and typed helpers such as <code>registerReadDataByIdentifierHandler</code>.</li>
<li><code>examples/exampleDoIPServer.cpp</code> — creates and configures a <code>DoIPServer</code>, sets logging level and starts listener threads that accept TCP connections.</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
ServerModel interface (important callbacks)</h2>
<p>The <code>DoIPServerModel</code> struct (see <code><a class="el" href="DoIPServerModel_8h.html">inc/DoIPServerModel.h</a></code>) exposes a few key callbacks your application implements. A concise summary:</p>
<ul>
<li><code>onOpenConnection(IConnectionContext &amp;ctx)</code> — called when a new connection is established.</li>
<li><code>onCloseConnection(IConnectionContext &amp;ctx, DoIPCloseReason)</code> — called during graceful/abrupt close.</li>
<li><code>onDiagnosticMessage(IConnectionContext &amp;ctx, const DoIPMessage &amp;msg)</code> — called for locally-handled diagnostic messages.</li>
<li><code>onDownstreamRequest(IConnectionContext &amp;ctx, const DoIPMessage &amp;msg, ServerModelDownstreamResponseHandler cb)</code> — called when the state machine wants to forward a diagnostic request to a downstream transport (e.g. CAN). The implementation should return <code>DoIPDownstreamResult::Pending</code> if it will respond asynchronously and call <code>ctx.receiveDownstreamResponse()</code> when the response arrives.</li>
</ul>
<p>Below is a minimal example implementation that forwards messages to a hypothetical CAN backend and forwards the response to the connection context.</p>
<div class="fragment"><div class="line"><span class="comment">// inside your DoIPServerModel setup</span></div>
<div class="line">m_model.onOpenConnection = [](IConnectionContext &amp;ctx) noexcept {</div>
<div class="line">    <span class="comment">// Prepare per-connection state</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">m_model.onDownstreamRequest = [<span class="keyword">this</span>](IConnectionContext &amp;ctx, <span class="keyword">const</span> DoIPMessage &amp;msg,</div>
<div class="line">                                    <a class="code" href="namespacedoip.html#a683de81dce510b845d711f65f2405cd7">ServerModelDownstreamResponseHandler</a> cb) noexcept {</div>
<div class="line">    <span class="comment">// Convert DoIP diagnostic payload to CAN frames and send</span></div>
<div class="line">    <span class="keyword">auto</span> [payload, size] = msg.getDiagnosticMessagePayload();</div>
<div class="line">    ByteArray req(payload, payload + size);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Simulate async send to CAN; real code would push to a queue or</span></div>
<div class="line">    <span class="comment">// post to a worker thread that interacts with the hardware.</span></div>
<div class="line">    canTransport.sendAsync(req, [&amp;, cb, &amp;ctx](<span class="keyword">const</span> ByteArray &amp;canRsp){</div>
<div class="line">        <span class="comment">// When response arrives, notify DoIP connection</span></div>
<div class="line">        ctx.receiveDownstreamResponse(canRsp);</div>
<div class="line">        <span class="comment">// Optionally call provided callback to indicate handled</span></div>
<div class="line">        <span class="keywordflow">if</span> (cb) cb(canRsp, DoIPDownstreamResult::Handled);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> DoIPDownstreamResult::Pending;</div>
<div class="line">};</div>
<div class="ttc" id="anamespacedoip_html_a683de81dce510b845d711f65f2405cd7"><div class="ttname"><a href="namespacedoip.html#a683de81dce510b845d711f65f2405cd7">doip::ServerModelDownstreamResponseHandler</a></div><div class="ttdeci">std::function&lt; void(const ByteArray &amp;response, DoIPDownstreamResult result)&gt; ServerModelDownstreamResponseHandler</div><div class="ttdoc">Callback for downstream response notification.</div><div class="ttdef"><b>Definition:</b> <a href="DoIPServerModel_8h_source.html#l00032">DoIPServerModel.h:32</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4"></a>
Building the example</h1>
<p>The project uses CMake. From the repository root, run the following commands to build the library and the examples (recommended with a clean build directory):</p>
<div class="fragment"><div class="line">rm -rf build</div>
<div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake .. -DCMAKE_BUILD_TYPE=Release -DWITH_EXAMPLES=ON</div>
<div class="line">cmake --build . --parallel 4</div>
</div><!-- fragment --><p>On success the example binaries are available under <code>build/examples/</code>.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Running the example server</h1>
<p>The example executable is <code>exampleDoIPServer</code>. Run it from the build directory, optionally enabling loopback mode (binds announcements to 127.0.0.1 instead of broadcast):</p>
<div class="fragment"><div class="line">./examples/exampleDoIPServer [--loopback]</div>
</div><!-- fragment --><p>The program will:</p>
<ul>
<li>Configure the <code>DoIPServer</code> (VIN, logical address, announce interval).</li>
<li>Open UDP and TCP sockets for announcements and incoming diagnostic connections.</li>
<li>Start two threads: one that polls UDP announcements and one that waits for TCP connections and processes TCP messages.</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Customizing UDS behavior</h1>
<p>The example registers default UDS services and a few typed handlers in <code>ExampleDoIPServerModel</code>:</p>
<ul>
<li>Diagnostic Session Control (<code>0x10</code>) — registered via <code>m_uds.registerDiagnosticSessionControlHandler</code>.</li>
<li>ECU Reset (<code>0x11</code>) — registered via <code>m_uds.registerECUResetHandler</code>.</li>
<li>Read Data By Identifier (<code>0x22</code>) — registered via <code>m_uds.registerReadDataByIdentifierHandler</code>.</li>
<li>Tester Present (<code>0x3E</code>) — registered via <code>m_uds.registerTesterPresentHandler</code>.</li>
</ul>
<p>These typed helpers convert a raw diagnostic <code>ByteArray</code> request into typed parameters (for example a DID or a session type) and forward the request to the provided callback. The callback returns a pair of <code>uds::UdsResponseCode</code> and a <code>ByteArray</code> payload. Implement your own handlers to perform ECU-specific logic and return appropriate responses.</p>
<p>Example: register a handler for ReadDataByIdentifier to respond with a VIN value for DID <code>0xF190</code>:</p>
<div class="fragment"><div class="line">m_uds.registerReadDataByIdentifierHandler([<span class="keyword">this</span>](uint16_t did) {</div>
<div class="line">    <span class="keywordflow">if</span> (did == 0xF190) {</div>
<div class="line">        ByteArray response = {...}; <span class="comment">// data bytes: [DID hi, DID lo, data...]</span></div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(uds::UdsResponseCode::PositiveResponse, response);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(uds::UdsResponseCode::RequestOutOfRange, ByteArray{0x22});</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Integrating a real downstream transport</h1>
<p>The example uses <code>uds::UdsMock</code> to simulate downstream behavior. For a real ECU you should implement <code>ServerModelDownstreamHandler</code> in <code>DoIPServerModel::onDownstreamRequest</code> to forward diagnostic messages to the physical bus (e.g., CAN) and call <code>ctx.receiveDownstreamResponse()</code> when a response arrives. The state machine will handle timeouts and transitions for you.</p>
<p>Simple downstream handler sketch:</p>
<div class="fragment"><div class="line">m_model.onDownstreamRequest = [<span class="keyword">this</span>](IConnectionContext &amp;ctx, <span class="keyword">const</span> DoIPMessage &amp;msg, <a class="code" href="namespacedoip.html#a683de81dce510b845d711f65f2405cd7">ServerModelDownstreamResponseHandler</a> cb) {</div>
<div class="line">    <span class="comment">// send msg to CAN</span></div>
<div class="line">    <span class="comment">// when response received: ctx.receiveDownstreamResponse(responseByteArray);</span></div>
<div class="line">    <span class="keywordflow">return</span> DoIPDownstreamResult::Pending;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Diagram: ServerModel interactions</h1>
<p>Below is a PlantUML diagram illustrating <code>DoIPServer</code>, <code>DoIPConnection</code>, <code>DoIPServerModel</code> and a downstream UDS/CAN backend interaction.</p>
<p><img src="ServerModel.svg" alt="" style="pointer-events: none;" class="inline" title="ServerModel"/></p>
<h1><a class="anchor" id="autotoc_md9"></a>
Logging and debugging tips</h1>
<ul>
<li>The library uses <code>spdlog</code>. Set the log level early in <code>main</code>:</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classdoip_1_1Logger.html#a2ab79937b1d3d2bad716af589746fead">doip::Logger::setLevel</a>(spdlog::level::debug);</div>
<div class="ttc" id="aclassdoip_1_1Logger_html_a2ab79937b1d3d2bad716af589746fead"><div class="ttname"><a href="classdoip_1_1Logger.html#a2ab79937b1d3d2bad716af589746fead">doip::Logger::setLevel</a></div><div class="ttdeci">static void setLevel(spdlog::level::level_enum level)</div><div class="ttdef"><b>Definition:</b> <a href="Logger_8h_source.html#l00095">Logger.h:95</a></div></div>
</div><!-- fragment --><ul>
<li>Enable <code>--loopback</code> while testing locally to avoid network broadcast.</li>
<li>If the example appears unresponsive, check that TCP sockets were successfully created. The example logs critical errors when socket setup fails.</li>
</ul>
<h1><a class="anchor" id="autotoc_md10"></a>
Troubleshooting common issues</h1>
<ul>
<li><code>exampleDoIPServer</code> exits immediately with critical log about sockets:<ul>
<li>Ensure you have sufficient privileges to bind the requested ports.</li>
<li>Try running on loopback or using a system port range allowed by your OS.</li>
</ul>
</li>
<li>UDS handler not called:<ul>
<li>Confirm the incoming diagnostic request is parsed correctly. Use the library logging to inspect raw message bytes.</li>
<li>If using downstream forwarding, ensure <code>onDownstreamRequest</code> is set and that the downstream transport calls back to <code>IConnectionContext::receiveDownstreamResponse</code>.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md11"></a>
Documentation / Doxygen</h1>
<p>If you generate documentation with Doxygen, the file <code><a class="el" href="ExampleDoIPServer_8md.html">doc/ExampleDoIPServer.md</a></code> will be picked up automatically if <code>DOC_DIR</code> or the <code>INPUT</code> setting in <code>Doxyfile</code> includes the <code>doc</code> directory. Run:</p>
<div class="fragment"><div class="line">doxygen Doxyfile</div>
</div><!-- fragment --><p>After generation, look for the "Example DoIP Server Tutorial" page in the generated HTML documentation.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Message flow and payload types</h1>
<p>This repository and the example server follow the DoIP payload conventions used in the examples and tests. Important details to understand when implementing or testing downstream forwarding:</p>
<ul>
<li>Incoming diagnostic requests from the client are sent as DoIP Diagnostic Messages (payload type 0x8001).</li>
<li>Immediately after receiving a diagnostic message the DoIP server sends a Diagnostic Ack (payload type 0x8002) back to the client. This ack is sent regardless of whether the message will be handled locally or forwarded downstream. The ack acknowledges receipt at the DoIP transport level.</li>
<li>If the server forwards the diagnostic request to a downstream transport (for example, CAN), it does so only for Diagnostic Messages (0x8001).</li>
<li>When a downstream response arrives, the DoIP server sends that response back to the client as a Diagnostic Message (0x8001). That means the client may observe two DoIP messages for a single request: the Diagnostic Ack (0x8002) and later the downstream Diagnostic Message (0x8001) containing the actual UDS response.</li>
</ul>
<p>ISO 13400 describes DoIP message and payload types. The immediate ack behaviour is consistent with a transport-level acknowledgement: the server confirms reception on the DoIP link while the actual diagnostic response may be pending. If you require strict timing or synchronous behaviour, do not rely on the ack as an application-level confirmation — always await the downstream Diagnostic Message for the functional UDS response.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Next steps</h1>
<ul>
<li>Replace <code>uds::UdsMock</code> with a real UDS stack or backend for production.</li>
<li>Extend the example model with additional UDS services as needed. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
